# 5G/IoT Network Simulation Project Explanation

## Problem Statement
The complexity of modern 5G networks lies in managing diverse traffic types—ranging from critical emergency signals and high-bandwidth video streams to massive IoT sensor data—within a dynamic physical environment. Standard routing protocols often fail to differentiate between these traffic types effectively under stress, leading to dropped emergency calls or buffering video during congestion. 

**The core problem this project addresses is:** How to maintain strict Quality of Service (QoS) requirements (latency, reliability, bandwidth) for heterogeneous traffic types in a volatile 5G network environment subject to user mobility, base station failures, and traffic surges. The project implements and tests an **Adaptive QoS Routing** algorithm that dynamically prioritizes and routes packets based on their specific needs and the current network state.

---

## Detailed File Analysis

### 1. `mainapp.py` - The Simulation Engine
**Significance:**
This is the heart of the project. It acts as the "Physics Engine" and "Network Stack" for the simulation. It creates the virtual world where nodes exist, move, and communicate. Without this file, there is no simulation.

**What it does in detail:**
-   **Entity Modeling**: Defines classes for `Node`, `EnbNode` (Base Stations), `UeNode` (Users), `IotNode`, and `CoreNode`. It models their physical properties (position, effective range) and network properties (queue size, processing capacity).
-   **Traffic Generation**: Simulates realistic traffic patterns (bursty IoT data, steady video streams, rare but critical emergency signals).
-   **Mobility**: Implements random walk models for User Equipment (UE) to simulate real-world movement within a defined stadium/city radius.
-   **Adaptive Routing Logic**: This is the key innovation. The `EnbNode._get_next_hop` methods calculate the "best" next node for a packet based on a weighted score of:
    -   **Load**: How busy the neighbor is.
    -   **Distance**: How close the neighbor is to the destination.
    -   **Priority**: The importance of the traffic type (Emergency > Video > Messaging).
-   **Execution**: Runs the simulation loop, calculating state changes every `0.1` seconds, and logs every packet's journey.

**Connections:**
-   **Input**: Takes command-line arguments for simulation parameters (simulation time, number of nodes).
-   **Output**: distinct CSV log files in the `results/` directory and visual snapshots (`network_topology.png`). These outputs are the *inputs* for `simulation.py`.

### 2. `simulation.py` - The Analysis Dashboard
**Significance:**
This file acts as the "Frontend" or "Analytics Suite". Raw simulation data (thousands of packet logs) is incomprehensible on its own. `simulation.py` processes this raw data into meaningful insights, allowing users to verify if the Adaptive QoS algorithm actually worked.

**What it does in detail:**
-   **Data Ingestion**: Reads the CSV files generated by `mainapp.py` (`scenario_X_timeseries.csv`).
-   **Visualization**: Uses `matplotlib` to render:
    -   **Time-Series Plots**: Latency, Throughput, and Reliability over time.
    -   **Comparative Charts**: Bar charts comparing performance across different scenarios (e.g., "Normal" vs. "Emergency").
    -   **Load Heatmaps**: Visualizes how much stress each base station is under.
-   **Interactive Dashboard**: Provides a GUI (if run locally) to toggle between scenarios and views.
-   **Reporting**: Contains logic to generate an HTML report (`generate_report` method) summarizing findings.

**Connections:**
-   **Input**: Consumes the `results/` CSV files created by `mainapp.py`.
-   **Dependent**: Is imported and used by `create_report.py` to automate report generation.

### 3. `create_report.py` - The Reporting Utility
**Significance:**
This is a helper script designed for automation and consistency. It ensures that a standardized report is generated after a simulation run, even if the user doesn't interact with the dashboard GUI. It serves as a bridge between the raw outcomes and a final deliverable.

**What it does in detail:**
-   **Data Patching**: Checks if the summary data is missing calculated fields (like a "QoS Score") and adds them if necessary, ensuring data completeness.
-   **Automation**: Instantiates the `AdaptiveQoSDashboard` from `simulation.py` in a non-interactive mode.
-   **Execution**: Triggers the generation of `qos_report.html` and `qos_summary_export.csv`.

**Connections:**
-   **Imports**: Directly imports `AdaptiveQoSDashboard` from `simulation.py`.
-   **Input**: Reads `results/simulation_summary.csv`.

---

## Architectural Flow
1.  **Run `mainapp.py`**:
    *   *Action*: Simulates the network, routes packets, handles failures.
    *   *Output*: Raw data CSVs in `results/`.
2.  **Run `create_report.py` (or `simulation.py`)**:
    *   *Action*: Reads the CSVs from step 1.
    *   *Process*: Aggregates stats, calculates averages, renders graphs.
    *   *Output*: `qos_report.html`, visual plots, and interactive dashboard.

This separation of concerns (Simulation vs. Analysis) allows for expensive simulations to be run once (e.g., on a server) and analyzed multiple times (e.g., on a local machine) without re-running the heavy computation.
